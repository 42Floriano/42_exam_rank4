/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   picoshell_2c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: albertini <albertini@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/20 23:24:50 by albertini         #+#    #+#             */
/*   Updated: 2024/11/27 11:40:25 by albertini        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//Faire les declaration d'en-tête
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
 
int picoshell(char **args[]) 
{
	int nCommand = 0;
	
	while (args[nCommand] != NULL)
		nCommand++;
	if (nCommand == 0)
	{
		perror("No commands passed!");
		return (-1);
	}
	int pipes[nCommand - 1][2];
	for(int i = 0; i < nCommand - 1; i++)
	{
		if (pipe(pipes[i]) == -1)
		{
			perror("Pipe error");
			exit(EXIT_FAILURE);
		}
	}
	for (int i = 0; i < nCommand; i++)
	{
		pid_t pid = fork();
		if (pid == -1)
		{
			perror("Fork error");
			exit(EXIT_FAILURE);
		}
		if (pid == 0)
		{
		//if it's not the first command do this:
		if (i > 0)
			dup2(pipes[i - 1][0], STDIN_FILENO);
		//if it's not the last command do this:
		if (i < nCommand - 1)
			dup2(pipes[i][1], STDIN_FILENO);
		//after giving stdin and stdout close the in and out
		for (int j = 0; j < nCommand - 1; j++)
		{
			close(pipes[j][0]);
			close(pipes[j][1]);
		}
		//execute command
		if (execvp(args[i][0], args[i]) == -1)
		{
			perrro("execvp error");
			exit(EXIT_FAILURE);
		}
		}
	}
	for (int j = 0; j < nCommand - 1; j++)
	{
		close(pipes[j][0]);
		close(pipes[j][1]);
	}
	for (int y = 0; y < nCommand; y++)
	{
		if (wait() == -1)
		{
			perror("wait error");
			exit(EXIT_FAILURE);
		}
	}
		
	//1. compter le nombre de commandes
	
	//2. Creer les pipes avec pipe() nCommand -1
	//3. Créer fork avec pid fork() nCommand
	//4. Gérer la sortie et entrée avec dup2, stdin, stdout
	//4.5 fermture des descripteur utilisé par les enfants avec close
	//5 execution des commandes avec execvp
	//6. fermeture des pipes parents
	//7. attente des processus enfants avec wait()
return (0);
}

// Exemple d'utilisation
int main() {
    // Exemple : ls | grep .c | wc -l
    char *cmd1[] = {"ls", NULL};
    char *cmd2[] = {"grep", ".c", NULL};
    char *cmd3[] = {"wc", "-l", NULL};
    char **commands[] = {cmd1, cmd2, cmd3, NULL};

    // Appeler picoshell
    if (picoshell(commands) == -1) {
        fprintf(stderr, "Erreur dans l'exécution de picoshell.\n");
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

